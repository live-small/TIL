`Table of Keyword`

> [늘 궁금했던 프로토타입](#프로토타입)  
> [특정문자 외의 값 찾기](#정규표현식)  
> [정규표현식에서 변수이용할 수 있어?](#정규표현식-변수이용)  
> [join을 활용하자](#join)  
> [궁금증](궁금한-것들)

#

### 프로토타입

#### `프로토타입의 역할`

JS는 프로토타입을 기반으로 상속을 구현하며, 상속으로 불필요한 중복을 제거할 수 있다.  
\*중복을 제거한다 = 코드를 재사용한다 -> 유지보수하기 좋다.

#### `상속, 그게 왜 필요해?`

> 생성자 함수 : 템플릿, 클래스
> 인스턴스: 템플릿에 값을 할당해서 만든 객체

생성자 함수로 인스턴스를 생성할 경우, 생성자 함수에 있는 프로퍼티(상태 데이터), 메서드(동작)를 참조하는게 아니라, **새롭게 만들어서 할당**받는다.
즉, `생성자 함수의 메소드` === `인스턴스의 메소드`를 일치비교한다면, `false`.

하나의 생성자 함수로 100개, 1000개 이상의 인스턴스를 만들경우, 메모리에 동일한 프로퍼티, 메서드가 엄청 많아지게 되고, 불필요한 공간 낭비가 생긴다.
하지만, **참조하는 경우**라면 **중복**을 줄일 수 있다.  
어떻게 참조할 수 있는지를 알아보기 전에, 프로토타입과 생성자 함수의 관계를 알아보자.

#### 프로토타입과 생성자 함수의 관계

생성자 함수는 자신의 프로토타입 객체가 존재한다.
생성자 함수가 생성되는 시점에 함께 생성되고,
서로를 인지하기 위해, 생성자 함수는 `prototype 프로퍼티`로,
프로토타입 객체는 `constructor 프로퍼티`로 서로를 포인팅한다.

- 조금 더 자세히
  - 함수 생성 방식마다, 내부 원리의 차이가 있음.
  - 함수 선언문일 경우,
    - 런타임 전, 함수호이스팅에 의해 함수 선언 & 객체할당이 이루어진다.
      이때 프로토타입도 더불어 생성되어 생성자 함수 prototype property에 바인딩된다.

#### 인스턴스와 프로토타입 객체의 관계

```javascript
function person(name, age) {
  this.name = name;
  this.age = age;
  this.getPersonData = function () {
    return `name: ${name}, age: ${age}`;
  };
}

const test = new person("bear", 20); // (1)
```

(1)의 코드와 같이 new 키워드를 통해 person를 토대로 인스턴스를 만든다.

##### person -----(a)----- person.prototype -----(b)----- test

(a): 프로토타입 접근 - `person.prototype` 생성자함수 접근 - `person.prototype.constructor`  
(b)는 프로토타입 접근 - `test.__proto__`

참고  
[프로토타입객체 vs 프로토 프로퍼티](https://www.youtube.com/watch?v=wT1Bl5uV27Y)  
모던 자바스크립트 deep dive, 19장

#

### 정규표현식

관련문제: [프로그래머스-뉴스클러스터링](https://programmers.co.kr/learn/courses/30/lessons/17677)  
\* [내가 푼 코드](https://github.com/live-small/problem-solving-/blob/main/programmers/Lv2/%EB%89%B4%EC%8A%A4%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81.js)

#### 영어소문자 외의 모든 값을 뽑아내려면 ? `/[^a-z]/g`

#### 처음 생각 한 것, `/[\W\d]/g`, 이건 왜 안될까?

`\w`는 영문자 + 숫자 + `_`(underscore)을 매칭함.  
`\W`는 `\w`의 부정형.

즉, underscore 을 제대로 처리하지 못함. (= `_`도 매칭되야하는데, 매칭되지 않음)  
따라서, `[\W\d_]`로 언더스코어를 넣어주면 동일하게 처리됨.

- 추가정리
  - `\w`: **영문자, 숫자, \_(언더스코어)**
    - `\w` === `[0-9a-zA-Z_]`
    - 숫자도 문자임, 간과하지 말기!
  - 대괄호 안은 문자집합을 담을 수 있음.
    - 문자집합에 포함된 모든 원소를 포인팅함.
    - `/[a-z0-9]/g`: 영어소문자, 숫자를 포인팅.
  - `/^a/g` : 대괄호 안이 아닌, 밖에 ^는 맨 앞을 의미함.
    - a로 시작하는 값을 매칭함.
    - 대괄호 안의 ^는 부정을 의미함.

#

### 정규표현식, 변수이용

#### 정규표현식 인자로 변수를 이용할 수 있을까?

`RegExp`객체를 만들어 전달하면 가능하다.

```javascript
const days = ["Sun", "Mon", "Tue", "Wen"];
const reg = new RegExp(days[0], "g");
let sentence = "08.22(Sun) is a holiday ";
let parsingDay = sentence.match(reg); // Sun
```

1. `RegExp`객체의 인자는 찾을 변수명, 찾는 조건 2가지
2. 찾는 조건은 g(만족하는 모든 값), i(대소문자 구분 x)을 의미

#

### join

`join`은 배열의 원소를 합쳐, 문자열로 바꿔주는 메서드다.
원소 사이에 넣고 싶은 값을 인자로 받는다.

```javascript
console.log(["", "4seveneight", ""].join(`원소 사이`));
// output: 원소 사이4seveneight원소 사이
```

#### 이걸 어디에 활용할까?

```javascript
const numbers = ["zero", "one", "two"];
let test = "onezero3two";

for (let i = 0; i < numbers.length; i++) {
  let arr = test.split(numbers[i]);
  test = arr.join(i);
}
```

`split`로 찾는 문자를 기준으로 배열을 만들고, `join`의 인자를 통해 원하는 값으로 바꿀 수 있다.
`split`인자가 맨 앞 혹은 맨 뒤라면, 빈 원소가 생긴다.

##### 참고

[MDN > join](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/join)
[카카오채용인턴십 - 숫자문자열과 영단어 > 다른사람 풀이](https://programmers.co.kr/learn/courses/30/lessons/81301/solution_groups?language=javascript)

#

### 궁금한 것들

TIL로 배운 것들을 정리하면서 궁금한 내용을 기록해두는 공간.  
시간 날 때, 하나씩 곰곰히 생각해보기

#### 근데 왜 `\w`에 언더스코어까지 포함한걸까?

영숫자에 언더스코어를 자주 사용하는 건가?
